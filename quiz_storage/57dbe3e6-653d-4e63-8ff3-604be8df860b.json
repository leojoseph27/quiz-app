{
  "questions": [
    {
      "question": "Who is considered the \"father of Java\"?",
      "options": [
        "Mike Sheridan",
        "Patrick Naughton",
        "James Gosling",
        "Sun Microsystems"
      ],
      "correct_answer": "James Gosling"
    },
    {
      "question": "Which keyword is used in Java to achieve inheritance?",
      "options": [
        "super",
        "this",
        "import",
        "extends"
      ],
      "correct_answer": "extends"
    },
    {
      "question": "What is the primary benefit of Java's platform independence?",
      "options": [
        "It allows direct manipulation of memory.",
        "The same bytecode can run on different operating systems.",
        "It simplifies the use of pointers.",
        "It supports multiple inheritance."
      ],
      "correct_answer": "The same bytecode can run on different operating systems."
    },
    {
      "question": "Which feature helps make Java a secure language?",
      "options": [
        "Explicit memory management using pointers.",
        "Direct access to system hardware.",
        "Automatic Garbage Collection and prevention of out-of-bounds array access.",
        "Support for multiple inheritance."
      ],
      "correct_answer": "Automatic Garbage Collection and prevention of out-of-bounds array access."
    },
    {
      "question": "What is the primary function of the Java Virtual Machine (JVM)?",
      "options": [
        "To compile Java source code into bytecode.",
        "To translate bytecode into machine-specific code.",
        "To write Java source code.",
        "To manage the operating system."
      ],
      "correct_answer": "To translate bytecode into machine-specific code."
    },
    {
      "question": "Which feature of Java allows classes to be added or methods modified without changing the original code?",
      "options": [
        "Platform independence.",
        "Bytecode compilation.",
        "Method overriding.",
        "Class loading."
      ],
      "correct_answer": "Method overriding."
    },
    {
      "question": "Which component is responsible for converting Java source code into bytecode?",
      "options": [
        "Java Runtime Environment (JRE)",
        "Java Development Kit (JDK)",
        "Java Virtual Machine (JVM)",
        "Java Compiler"
      ],
      "correct_answer": "Java Compiler"
    },
    {
      "question": "Which of the following is NOT a component of the Java Runtime Environment (JRE)?",
      "options": [
        "Java Virtual Machine (JVM)",
        "Class Libraries",
        "Development Tools",
        "Other files to execute Java code"
      ],
      "correct_answer": "Development Tools"
    },
    {
      "question": "Which of the following data types in Java is used to store whole numbers and occupies 16 bits of memory?",
      "options": [
        "byte",
        "int",
        "short",
        "long"
      ],
      "correct_answer": "short"
    },
    {
      "question": "What suffix is used to denote a long integer in Java?",
      "options": [
        "f or F",
        "d or D",
        "i or I",
        "l or L"
      ],
      "correct_answer": "l or L"
    },
    {
      "question": "Which data type is used to store single characters in Java?",
      "options": [
        "double",
        "boolean",
        "char",
        "int"
      ],
      "correct_answer": "char"
    },
    {
      "question": "Which statement immediately terminates a loop in Java?",
      "options": [
        "continue",
        "break",
        "return",
        "skip"
      ],
      "correct_answer": "break"
    },
    {
      "question": "Which of the following is NOT a category of operators in Java?",
      "options": [
        "Arithmetic",
        "Conditional",
        "Logical",
        "Assignment"
      ],
      "correct_answer": "Conditional"
    },
    {
      "question": "Which bitwise operator returns 1 only if both corresponding bits are 1?",
      "options": [
        "|",
        "^",
        "&",
        "~"
      ],
      "correct_answer": "&"
    },
    {
      "question": "Which operator is a one-line replacement for an `if-else` statement?",
      "options": [
        "Bitwise operator",
        "Shift operator",
        "Ternary operator",
        "Assignment operator"
      ],
      "correct_answer": "Ternary operator"
    },
    {
      "question": "Which type of casting automatically converts a smaller data type to a larger one?",
      "options": [
        "Narrowing",
        "Explicit",
        "Widening",
        "Downcasting"
      ],
      "correct_answer": "Widening"
    },
    {
      "question": "Which type of variable in Java is associated with an object's lifecycle and is not declared with the `static` keyword?",
      "options": [
        "Local Variable",
        "Static Variable",
        "Instance Variable",
        "Class Variable"
      ],
      "correct_answer": "Instance Variable"
    },
    {
      "question": "Which loop type in Java guarantees that the loop body will execute at least once?",
      "options": [
        "while loop",
        "for loop",
        "do-while loop",
        "if statement"
      ],
      "correct_answer": "do-while loop"
    },
    {
      "question": "What is the primary purpose of the 'for-each' loop?",
      "options": [
        "To define a loop with initialization, condition, and increment in one line.",
        "To iterate over arrays or collections in a simplified manner.",
        "To create nested loops for complex tasks.",
        "To dynamically allocate memory for variables."
      ],
      "correct_answer": "To iterate over arrays or collections in a simplified manner."
    },
    {
      "question": "What does `int[][] a = new int[3][4];` declare?",
      "options": [
        "A 1-dimensional array that can hold 7 integers.",
        "A 2-dimensional array that can hold a maximum of 7 integers.",
        "A 1-dimensional array that can hold 12 integers.",
        "A 2-dimensional array that can hold a maximum of 12 integers."
      ],
      "correct_answer": "A 2-dimensional array that can hold a maximum of 12 integers."
    },
    {
      "question": "What type of class is the Calendar class?",
      "options": [
        "Concrete class",
        "Final class",
        "Abstract class",
        "Static class"
      ],
      "correct_answer": "Abstract class"
    }
  ],
  "original_input_text": "Unit II [9 T + 8L] Introduction to Java: History, Versioning, The Java Virtual\nMachine, Byte code, Writing simple java program, Language Components:\nPrimitive Data Types, Comments, Keywords, literals, The break Statement, The\ncontinue Statement, Operators – Casts and Conversions, Arrays. Introduction to\nclasses and methods, constructors, Passing Objects to Methods, Method\nOverloading, Static and final, The this Reference, finalize, inner and nested classes.\nInheriting class, extends, member access and inheritance, super keyword, Object\nclass. Dynamic method dispatch, method overriding, abstract class, interface,\npackages, import statement.\nIntroduction to Java programming\nJava is one of the most widely used and popular programming\nlanguages. The flexibility of writing a java code on one machine and running it on\nseveral other machines makes it popular.\nHistory of Java Programming Language\nJava is an object oriented programming language developed by Sun\nMicrosystems in early 1990 by developers James Gosling, Mike Sheridan and\nPatrick Naughton. In 1991 James Gosling and his friends formed a team called\nGreen Team to further work on this project. The original idea was to develop this\nprogramming language for digital devices such as television, set-top box, remote\netc. Later this idea was dropped and Java was developed for internet programming.\nJames Gosling is considered the original developer of Java\nlanguage. He is also known as the father of Java. He started on this in the early\n1990s. He originally named it Greentalk and the extension was .gt.Programming\nlanguage renamed from Greentalk to Oak:When the Green team (James Gosling,\nMike Sheridan and Patrick Naughton) started working on it, it was renamed to\nOak. Oak is a tree name, which is considered a symbol of strength and is a national\ntree in many countries such as the U.S.A., France, Germany, Romania, etc.\nJavaSEversion Versionno ReleaseDate\nJDK1.0(Oak) 1.0 January1996\nJDK1.1\n1.1 February1997\nJ2SE1.2(Playground) 1.2 December1998\nJ2SE1.3(Kestrel) 1.3 May2000\nJ2SE1.4(Merlin) 1.4 February2002\nJ2SE5.0(Tiger) 1.5 September2004\nJavaSE6 1.6 December2006\n(Mustang)\nJavaSE7(Dolphin) 1.7 July2011\nJavaSE9 9 September,21st2017\nJavaSE10 10 March,20th2018\nJavaSE11 11 September,25th2018\nJavaSE12 12 March,19th2019\n13\nJavaSE13 September,17th2019\n14\nJavaSE14 March,17th2020\n15\nJavaSE15 September,15th2020\n16\nJavaSE16 March,16th2021\n17\nJavaSE17 September,14th2021\n18\nJavaSE18 March,22nd2022\nSeptember,20th2022\n19\nJavaSE19\nJavaSE20 20 March,21st2023\nFeatures of Java\nFollowing are some of the useful and advanced features of java:\n1. Simple:- Java is a very simple programming language, it is easy to learn, read\nand write in Java. The syntax of Java is clean and easy to understand.Java syntax is\nsimilar to C/C++ so it is easier to learn Java, if one is familiar with C or C++. Java\ndoesn’t use the complex features of C and C++ such as Pointers, go to statements,\npreprocessors/ header files, multiple inheritance, operator overloading etc.There is\nno need to remove unreferenced objects explicitly as there is an Automatic\nGarbage Collection in Java.\n2. Platform Independent:- Java is a platform independent language.\nCompiler(javac) converts source code (.java file) to the byte code(.class file). JVM\nexecutes the bytecode produced by the compiler. This byte code can run on any\nplatform such as Windows, Linux, Mac OS etc. Which means a program that is\ncompiled on windows can run on Linux and vice-versa.Each operating system has\ndifferent JVM, however the output they produce after execution of bytecode is\nsame across all operating systems. That is why we call java a platform independent\nlanguage.\n3. Secure:- Security is one of the biggest concerns in programming languages as\nthese programming languages are used to develop some of the critical and sensitive\napplications that need to be secured such as banking applications. Java is more\nsecure than C/C++ as it does not allow developers to create pointers, thus it\nbecomes impossible to access a variable from outside if it’s not been initialized.\nWe don’t have pointers and we cannot access out of bound arrays in java. So\nsecurity flaws like stack corruption or buffer overflow are impossible to exploit in\nJava.\n4. Object-Oriented Programming language:-Object oriented programming is a\nway of organizing programs as collection of objects, each of which represents an\ninstance of a class.4 main concepts of Object Oriented programming are:\n1. Abstraction 2.Encapsulation 3. Inheritance 4. Polymorphism\n5. Robust:- Java is significantly faster than other traditional interpreted\nprogramming languages. Compiled java code which is known as byte code is like a\nmachine code, that allows a faster execution. Java uses a Just in Time compiler\nwhich can execute the code on demand, this allows it to execute only the method\nthat is being called, which makes it faster and more efficient.\n6. Distributed:- Using the Java programming language we can create distributed\napplications. RMI(Remote Method Invocation) and EJB(Enterprise Java Beans)\nare used for creating distributed applications in java. The java programs can be\ndistributed on more than one systems that are connected to each other using\ninternet connection. Objects on one JVM (java virtual machine) can execute\nprocedures on a remote JVM.\n7. Multithreading:-Java supports multithreading. Multithreading is a Java feature\nthat allows concurrent execution of two or more parts of a program for maximum\nutilization of CPU.\n8. Portable:-Java code that is written on one machine can run on another machine.\nThe platform independent bytecode can be carried to any platform for execution\nthat makes java code portable.\n9. Architectural Neutral:- Java is a platform independent language, which means\nprograms written and compiled on one machine can run on any other machine\nhaving a different operating system. Java follows the principle of “Write once run\nanywhere“. Compiler converts the java file into byte-code and this bytecode is\nmachine independent, java virtual machine can easily translate this byte code into\nmachine specific code. This makes Java an architectural neutral programming\nlanguage.\n10. Dynamic:- Java is a dynamic programming language. OOPs allows\ndevelopers to add new classes to the existing packages, add new methods to the\nexisting classes as well as modifying the method without changing the original\nmethod code by using the concept of method overriding. All these features make\njava dynamic. It also allows classes to be loaded on demand. It also supports\nfunctions from its native languages such as C and C++.\nJava Virtual Machine\nJava is a high level programming language. A program written in\nhigh level language cannot be run on any machine directly. First, it needs to be\ntranslated into that particular machine language. The javac compiler does this, it\ntakes a java program (.java file containing source code) and translates it into\nmachine code (referred as byte code or .class file).\nJava Virtual Machine (JVM) is a virtual machine that resides in the real\nmachine (your computer) and the machine language for JVM is byte code. This\nmakes it easier for the compiler as it has to generate byte code for JVM rather than\ndifferent machine code for each type of machine. JVM executes the byte code\ngenerated by the compiler and produces output. JVM is the one that makes the java\nplatform independent.\nThe Java Virtual machine (JVM) is the virtual machine that runs on an\nactual machine (your computer) and executes Java bytecode. The JVM doesn’t\nunderstand Java source code, that’s why we need to have javac compiler that\ncompiles *.java files to obtain *.class files that contain the byte codes understood\nby the JVM. JVM makes java portable (write once, run anywhere). Each operating\nsystem has a different JVM, however the output they produce after execution of\nbyte code is the same across all operating systems.That is why we call java a\nplatform independent language.\nJVM Architecture\nClass Loader: The class loader\nreads the .class file and saves the\nbyte code in the method area.\nMethod Area: There is only one\nmethod area in a JVM which is\nshared among all the classes. This\nholds the class level information of\neach .class file.\nHeap: Heap is a part of JVM\nmemory where objects are allocated. JVM creates a Class object for each .class\nfile.\nStack: Stack is also a part of JVM memory but unlike Heap, it is used for storing\ntemporary variables.\nPC Registers: This keeps the track of which instruction has been executed and\nwhich one is going to be executed. Since instructions are executed by threads, each\nthread has a separate PC register.\nNative Method stack: A native method can access the runtime data areas of the\nvirtual machine.\nNative Method interface: It enables java code to call or be called by native\napplications. Native applications are programs that are specific to the hardware and\nOS of a system.\nGarbage collection: A class instance is explicitly created by the java code and\nafter use it is automatically destroyed by garbage collection for memory\nmanagement.\nJVM Vs JRE Vs JDK\nJRE: JRE is the environment within which the java virtual machine runs. JRE\ncontains Java virtual Machine(JVM), class libraries, and other files excluding\ndevelopment tools such as compiler and\ndebugger.Which means you can run the\ncode in JRE but you can’t develop and\ncompile the code in JRE.JVM: JVM runs\nthe program by using classes, libraries and\nfiles provided by JRE.\nJDK: JDK is a superset of JRE, it contains\neverything that JRE has along with\ndevelopment tools such as compiler,\ndebugger etc.\nByte Code:- Byte Code can be\ndefined as an intermediate code generated\nby the compiler after the compilation of\nsource code(JAVA Program). This\nintermediate code makes Java a\nplatform-independent language.\nHow is Byte Code generated?\nCompiler converts the\nsource code or the Java program into the\nByte Code(or machine code), and the\nInterpreter executes the byte code on the\nsystem. The Interpreter can also be called\nJVM(Java Virtual Machine). The byte\ncode is the common piece between the\ncompiler(which creates it) and the Interpreter (which runs it).\nLanguage Components\nData types in java\nThere are two types of data types in java\n● Primitive Data type Non primitive data type\nPrimitive data type:-There are 8 types of Primitive data types in Java – Boolean,\nchar, byte, int, short, long, float, and double.\nPrimitive Data Types Table – Default Value, Size, and Range\nData Type Default Default size Range\nValue\nbyte 0 1 byte or 8 bits -128 to 127\nshort 0 2 bytes or 16 bits -32,768 to 32,767\nint 0 4 bytes or 32 bits 2,147,483,648 to 2,147,483,647\nlong 0 8 bytes or 64 bits 9,223,372,036,854,775,808 to\n9,223,372,036,854,775,807\nfloat 0.0f 4 bytes or 32 bits 1.4e-045 to 3.4e+038\ndouble 0.0d 8 bytes or 64 bits 4.9e-324 to 1.8e+308\nchar ‘\\u0000’ 2 bytes or 16 bits 0 to 65536\nboolean FALSE 1 byte or 2 bytes 0 or 1\nThere are ight primitive data types: boolean, char, byte, short, int, long,\nfloat and double. Java developers included these data types to maintain the\nportability of java as the size of these primitive data types do not change from one\noperating system to another.\nshort, int and long data types byte are used for storing whole numbers.\nfloat and double are used for fractional numbers.\nchar is used for storing characters(letters).\nboolean data type is used for variables that hold either true or false.\nInteger Types\nJava defines four integer types.Byte,short,int,long.All of these are signed\npositive and negative values. Integer types can hold whole numbers such as 123,\n-96, and 5639. The size of the values\nstored depends on the integer data type\nwe choose. Java supports four types of\nintegers; they are byte, short, int, and\nlong. Java does not support the concept\nof unsigned therefore all Java values are\nsigned meaning they can be positive or\nnegative.\nThe wider data types require more time for manipulation and therefore\nit is advisable to use smaller data types, wherever possible. For example, instead\nof storing a 50 in an int type variable, we must use a byte variable to handle this\nnumber. This will improve the speed of the execution of the program.. We can\nmake integers long by appending the letter L or I at the end of the number.\nExample 123L or 123l\nByte Data Type:- The byte data type is an example of primitive data type. It's An\n8-bit signed two's complement integer. Its value-range lies between -128 to 127\n(inclusive). Its minimum value is -128 and maximum value is 127. Its default value\nis 0.The byte data type is used to save memory in large arrays where the memory\nsavings is most required. It saves space because a byte is 4 times smaller than an\ninteger. It can also be used in place of \"int\" data type.\nExample: byte a = 10, byte b = -20\nShort Data TypeThe short data type is a 16-bit signed two's complement integer.\nIts value-range lies between -32,768 to 32,767 (inclusive). Its minimum value is\n-32,768 and maximum value is 32,767. Its default value is 0.The short data type\ncan also be used to save memory just like byte data type. A short data type is 2\ntimes smaller than an integer.\nExample: short s = 10000, short r = -5000\nInt Data Type:- The int data type is a 32-bit signed two's complement integer. Its\nvalue-range lies between - 2,147,483,648 (-2^31) to 2,147,483,647 (2^31 -1)\n(inclusive). Its minimum value is - 2,147,483,648and maximum value is\n2,147,483,647. Its default value is 0.The int data type is generally used as a default\ndata type for integral values unless there is no problem about memory. Example:\nint a = 100000, int b = -200000\nLong Data Type:- The long data type is a 64-bit two's complement integer. Its\nvalue-range lies between -9,223,372,036,854,775,808(-2^63) to\n9,223,372,036,854,775,807(2^63 -1)(inclusive). Its default value is 0. The long\ndata type is used when you need a range of values more than those provided by\nint.Example: long a = 100000L, long b = -200000L\nFloating Point Types:- There are two kinds of floating point storage in Java .The\nfloat type values are single-precision numbers while the double types represent\ndouble precision numbers. Table below gives the size and range of these two types.\nFloating point numbers are treated as double-precision quantities. To force them to\nprecision mode, we must append f or F to the numbers. Example: 23f or 56798e5F\nDouble:- Double-precision types are used when we need greater precision in\nstorage of numbers. All mathematical functions, such as sin, cos and sqrt return\ndouble type values. Floating point data types support a special value known as\nNot-a-Number (NaN), NaN is used to represent the result of operations such as\ndividing zero by zero, where an actual number is not produced. Most operations\nthat have NaN as an operand will produce NaN as a result.\nCharacter Type:- In order to store character constants in memory, Java provides\na character data type called char type that assumes a size of 2 bytes but, basically, it\ncan hold only a single character.\nBoolean Type:- Boolean type is used when we want to test a particular condition\nduring the execution of the programThere are only two values that a boolean type\ncan take: true or false. Boolean type is denoted by the keyword boolean and uses\nonly one bit of storage. All comparison operators return boolean type values.\nBoolean values are in selection and iteration statements.\nDeclaration and initialization of Variables\nIn Java, variables are the names of storage locations. After designing\nsuitable variable names, we must declare them to the compiler. A variable must be\ndeclared before it is used in the program.A variable can be used to store a value of\nany data type. Java allows any properly formed variable to have any declared data\ntype. The declaration statement defines the type of variable. The general form of\ndeclaration of a variable is:\ndatatype var1,var2,var3;\nEg:- int count;\nFloat x,y;\ndouble pi;\nbyte s;\nchar c1,c2,c3;\nAssignment statement :- The assignment operator in Java is used to assign a\nvalue to a variable. The syntax is:\ndatatype variablename =value;\nFor example: int x = 10; This statement assigns the value 10 to the variable x.\nComments in JAVA\nComments can be used to explain Java code, and to make it more readable.\nSingle-line Comments:- Single-line comments start with two forward slashes\n(//).Any text between // and the end of the line is ignored by Java (will not be\nexecuted).This example uses a single-line comment before a line of code:\n// This is a comment\nSystem.out.println(\"Hello World\");\nJava Multi-line Comments:- Multi-line comments start with /* and ends with\n*/.Any text between /* and */ will be ignored by Java.This example uses a\nmulti-line comment (a comment block) to explain the code:\n/* The code below will print the words Hello World\nto the screen*/\nSystem.out.println(\"Hello World\");\nKeywords\nKeywords or Reserved words are the words in a language that are\nused for some internal process or represent some predefined actions. These words\nare therefore not allowed to be used as variable names or objects.\nLiterals in Java\nA literal is a fixed value that we assign to a variable in a Program.\nInteger Literal:-Integer literals are assigned to the variables of data type byte,\nshort, int and long.\nbyte b = 100;\nshort s = 200;\nint num = 13313131;\nlong l = 928389283L;\nFloat Literals:- Used for data type float and double.\ndouble num1 = 22.4; float num2 = 22.4f;\nChar and String Literal:- Used for char and String type.\nchar ch = 'Z';\nString str = \"Nirmala college\";\nExample programs:-\n1. Java Program to Add two Numbers (use byte as data type)\n2. Java Program to Multiply two numbers.\n3. Java Program to read a number (entered by user)\nBreak :-When a break statement is encountered inside a loop, the loop is\nimmediately terminated and the program control resumes at the next statement\nfollowing the loop.The Java break statement is used to break loop or switch\nstatement. It breaks the current flow of the program at specified conditions. In the\ncase of an inner loop, it breaks only the inner loop.We can use Java break\nstatements in all types of loops such as for loop, while loop and do-while loop.\nSyntax: for (int i = 0; i < 10; i++) {\nif (i == 4) {\nbreak;\n}\nSystem.out.print(i + ” “);\n} output:- 0 1 2 3\nContinue Statement:-The continue statement is used in loop control structure\nwhen you need to jump to the next iteration of the loop immediately. It can be used\nwith for loop or while loop.The Java continue statement is used to continue the\nloop. It continues the current flow of the program and skips the remaining code at\nthe specified condition. In the case of an inner loop, it continues the inner loop\nonly.We can use Java continue statements in all types of loops such as for loop,\nwhile loop and do-while loop.\nSyntax://Java Program to demonstrate the use of continue statement\n//inside the for loop.\npublic class ContinueExample {\npublic static void main(String[] args) {\n//for loop\nfor(int i=1;i<=10;i++){\nif(i==5){\n//using continue statement\ncontinue;//it will skip the rest statement\n}\nSystem.out.println(i);\n}\n}\n}\nOutput:-1 2 3 4 6 7 8 9 10\nOPERATORS in JAVA\nOperator is a symbol that instructs the compiler to perform a\nspecific action. For example, a “+” operator instructs the compiler to perform\naddition, a “>” operator instructs the compiler to perform comparison, “=” for\nassignment.\nOperator and Operand:\nIn any operation, there is an operator and operands. For example: In a+b, the “+”\nsymbol is the operator and a & b are operands.\nTypes of Operator in Java:-\nOperators in java are classified in following eight categories:\n1) Arithmetic Operators\n2) Assignment Operators\n3) Unary Operators\n4) Logical Operators\n5) Relational operators\n6) Bitwise Operators\n7) Ternary Operator\n8) Shift Operators\nArithmetic Operators\n2) Assignment Operators\nCompound Assignments operators in java are: =, +=, -=, *=, /=, %=\nExample of Assignment Operators\npublic class JavaExample {\npublic static void main(String args[]) {\nint num1 = 10, num2;\nnum2 = num1;\nSystem.out.println(\"= Output:\n\"+num2);\nnum2 += num1;\nSystem.out.println(\"+= Output:\n\"+num2);\nnum2 -= num1;\nSystem.out.println(\"-= Output:\n\"+num2);\nnum2 *= num1;\nSystem.out.println(\"*= Output: \"+num2);\nnum2 /= num1;\nSystem.out.println(\"/= Output: \"+num2);\nnum2 %= num1;\nSystem.out.println(\"%= Output: \"+num2);\n}\n}\nUnary Operators\nThe Unary operators in Java involve a single operand. Java supports\nfollowing unary operators:\n● Unary minus(-)\n● Increment(++)\n● Decrement(- -)\n● NOT(!)\n● Bitwise Complement(~)\nnum++ is equivalent to num=num+1;\nnum— is equivalent to num=num-1;\nExample of Unary Operators\npublic class JavaExample {\npublic static void main(String args[]){\nint num1=100;\nint num2=200;\n//minus(-) unary operator\nint inverseNum = -num1;\nSystem.out.println(\"Opposite of num1: \"+inverseNum);\n//increment\nnum1++;\n//decrement\nnum2--;\nSystem.out.println(\"num1++ is: \"+num1);\nSystem.out.println(\"num2-- is: \"+num2);\n} }\nOutput: Opposite of num1: -100\nnum1++ is: 101\nnum2-- is: 199\nThe NOT(!) Operator reverses the logical state (true or false) of an operand. If an\noperand or condition is true, then the Logical NOT operator will make it false and\nvice-versa .If the value of a boolean variable 'bool' is true, then the value of !bool is\nfalse.If the value of 'bool' is false, then the value of !bool is true\nLogical Operators\nLogical Operators are used to evaluate the outcome of conditions. There\nare three logical operators: AND (&&), OR (||) and NOT (!). The AND and OR\noperators are used when multiple conditions are combined and we need to evaluate\nthe outcome as a whole.\nExample of Logical Operators\npublic class LogicalOperatorDemo {\npublic static void main(String args[]) {\nboolean b1 = true;\nboolean b2 = false;\nSystem.out.println(\"b1 && b2: \" + (b1&&b2));\nSystem.out.println(\"b1 || b2: \" + (b1||b2));\nSystem.out.println(\"!(b1 && b2): \" + !(b1&&b2));\n}\n}\nOutput: b1 && b2: false\nb1 || b2: true\n!(b1 && b2): true\nComparison(Relational) operators\nRelational operators are used to compare two operands.\nExample of Relational operators\npublic class JavaExample {\npublic static void main(String args[]) {\nint num1 = 10;\nint num2 = 50;\nif( num1 != num2 ){\nSystem.out.println(\"num1 and num2 are not\nequal\");\n}\nelse{\nSystem.out.println(\"num1 and num2 are\nequal\");\n}\nif( num1 > num2 ){\nSystem.out.println(\"num1 is greater than\nnum2\");\n}\nelse{\nSystem.out.println(\"num1 is not greater than num2\");\n}\nif( num1 < num2 ){\nSystem.out.println(\"num1 is less than num2\");\n}\nelse{\nSystem.out.println(\"num1 is not less than num2\");\n}\n}\n}\nBitwise Operators\nBitwise operators are used to perform bit-level operations. For performing\nan AND operation on two numbers (a & b), then these numbers are converted into\nbinary numbers and then the AND operation is performed. Finally, the compiler\nreturns a decimal equivalent of the output binary number.\nnum1 = 11; /* equal to 00001011*/\nnum2 = 22; /* equal to 00010110 */ Bitwise operator performs bit by bit\nprocessing.\nnum1 & num2 compares corresponding bits of num1 and num2 and generates 1 if\nboth bits are equal, else it returns 0. In our case it would return: 2 which is\n00000010 because in the binary form of num1 and num2 only second last bits are\nmatching.\nnum1 | num2 compares corresponding bits of num1 and num2 and generates 1 if\neither bit is 1, else it returns 0. In our case it would return 31 which is 00011111\nnum1 ^ num2 compares corresponding bits of num1 and num2 and generates 1 if\nthey are not equal, else it returns 0. In our example it would return 29 which is\nequivalent to 00011101\n~num1 is a complement operator that just changes the bit from 0 to 1 and 1 to\n0. In our example it would return -12 which is signed 8 bit equivalent to 11110100\nnum1 << 2 is the left shift operator that moves the bits to the left, discards the far\nleft bit, and assigns the rightmost bit a value of 0. In our case output is 44 which is\nequivalent to 00101100\nnum1 >> 2 is the right shift operator that moves the bits to the right, discards the\nfar right bit, and assigns the leftmost bit a value of 0. In our case output is 2 which\nis equivalent to 00000010\nExample of Bitwise Operators\npublic class BitwiseOperatorDemo {\npublic static void main(String args[]) {\nint num1 = 11; /* 11 = 00001011 */\nint num2 = 22; /* 22 = 00010110 */\nint result = 0;\nresult = num1 & num2;\nSystem.out.println(\"num1 & num2: \"+result);\nresult = num1 | num2;\nSystem.out.println(\"num1 | num2: \"+result);\nresult = num1 ^ num2;\nSystem.out.println(\"num1 ^ num2: \"+result);\nresult = ~num1;\nSystem.out.println(\"~num1: \"+result);\nresult = num1 << 2;\nSystem.out.println(\"num1 << 2: \"+result); result = num1 >> 2;\nSystem.out.println(\"num1 >> 2: \"+result);\n}\n}\nOutput:\nnum1 & num2: 2\nnum1 | num2: 31\nnum1 ^ num2: 29\n~num1: -12\nnum1 << 2: 44 num1 >> 2: 2\nTernary Operator\nTernary operator is the only operator in java that takes three operands.\nThis operator is frequently used as a one line replacement for if…else statement.\nSyntax: variable = Condition ? Expression1: Expression2\nIf the condition is true, the Expression1 executes. If the condition is false, the\nExpression2 executes.If the condition returns true, the result of Expression1 is\nassigned to the variable, else the result of Expression2 is assigned to the variable.\nExample of Ternary Operator\nimport java.util.Scanner;\npublic class Largest_Ternary\n{\npublic static void main(String[] args)\n{\nint a, b, c, d;\nScanner s = new Scanner(System.in);\nSystem.out.println(\"Enter all three numbers:\");\na = s.nextInt();\nb = s.nextInt();\nc = s.nextInt();\nd = c > (a > b ? a : b) ? c : ((a > b) ? a : b);\nSystem.out.println(\"Largest Number:\"+d);\n}\n}\nOutput: num2: 200\nnum2: 100\nShift Operators:-Shift operators are used to perform bit manipulation.\nShift operator example\npublic class JavaExample {\npublic static void main(String[] args) {\nint num = 24;\n//Left shift\nSystem.out.println(\"num<<2: \"+(num<<2));\n//Right shift\nSystem.out.println(\"num>>2: \"+(num>>2));\n}\n}\nOutput: num<<2: 96 num>>2: 6\nOperator Precedence in Java\nThis determines which operator needs to be evaluated first if an expression\nhas more than one operator. Operator with higher precedence at the top and lower\nprecedence at the bottom\nOperators Precedence\nUnary Operators ++ – – ! ~\nMultiplicative * / %\nAdditive + –\nShift << >> >>>\nRelational > >= < <=\nEquality == !=\nBitwise AND &\nBitwise XOR ^\nBitwise OR |\nLogical AND &&\nLogical OR ||\nTernary ?:\nAssignment = += -= *= /= %= > >= < <= &= ^= |=\nType Casting in java\nAssigning a value of one primitive data type to another primitive data\ntype is known as casting. There are two types of type casting in java.Type Casting\nin Java is the process of converting one data type to another data type using the\ncasting operator. To enable the use of a variable in a specific manner, this method\nrequires explicitly instructing the Java compiler to treat a variable of one data type\nas a variable of another data type.\nSyntax: datatype variableName = (datatype) value;\nTypes of Type Casting\nThere are two types of Type Casting in java:\n● Widening Type Casting\n● Narrow Type Casting\nWidening Type Casting :-A lower data type is transformed into a higher one by a\nprocess known as widening type casting. Implicit type casting and casting down\nare some names for it. It occurs naturally. Since there is no chance of data loss, it is\nsecure. Widening Type casting occurs when.\n● The target type must be larger than the source type.\n● Both data types must be compatible with each other.\nSyntax: larger_data_type variable_name = smaller_data_type variable;\n● Narrowing(explicit) type casting\n● Widening(implicit) type casting\nNarrow Type Casting:- The process of downsizing a bigger data type into a\nsmaller one is known as narrowing type casting. Casting up or explicit type casting\nare other names for it. It doesn’t just happen by itself. If we don’t explicitly do that,\na compile-time error will occur. Narrowing type casting is unsafe because data loss\nmight happen due to the lower data type’s smaller range of permitted values. A cast\noperator assists in the process of explicit casting.\nSyntax: smaller_data_type variable_name = (smaller_data_type)\nlarger_data_type_variable;\nTypes of Explicit Casting\nMainly there are two types of Explicit Casting:\n● Explicit Upcasting\n● Explicit Downcasting\nExplicit Upcasting :-Upcasting is the process of casting a subtype to a supertype\nin the inheritance tree’s upward direction. When a sub-class object is referenced by\na superclass reference variable, an automatic process is triggered without any\nfurther effort.\nExplicit Downcasting:-When a subclass type refers to an object of the parent\nclass, the process is referred to as downcasting. If it is done manually, the compiler\nissues a runtime ClassCastException error. It can only be done by using the\ninstanceof operator. Only the downcast of an object that has already been upcast is\npossible.\nVariables\nVariables are the data containers that save the data values during Java program\nexecution. Every Variable in Java is assigned a data type that designates the type\nand quantity of value it can hold. A variable is a memory location name for the\ndata.\nJava variable is a name given to a memory location. It is the basic unit of storage in\na program.\n● The value stored in a variable can be changed during program execution.\n● Variables in Java are only a name given to a memory location. All the\noperations done on the variable affect that memory location.\n● In Java, all variables must be declared before use.\nHow to Declare Variables in Java?\nWe can declare variables in Java as shown below\n;\n● datatype: Type of data that can be stored in this variable.\n● variable_name: Name given to the variable.\n● value: It is the initial value stored in the variable.\nTypes of Variables in Java\n1. Local Variables\n2. Instance Variables\n3. Static Variables\nLocal Variables :-A variable defined within a block or method or constructor is\ncalled a local variable.These variables are created when the block is entered, or the\nfunction is called and destroyed after exiting from the block or when the call\nreturns from the function.The scope of these variables exists only within the block\nin which the variables are declared.\nInstance Variables:-Instance variables are non-static variables and are declared in\na class outside of any method, constructor, or block. instance variables are declared\nin a class, these variables are created when an object of the class is created and\ndestroyed when the object is destroyed.Instance variables can be accessed only by\ncreating objects.We initialize instance variables using constructors while creating\nan object. We can also use instance blocks to initialize the instance variables.\nStatic Variables:-Static variables are also known as class variables.static variables\nare declared using the static keyword within a class outside of any method,\nconstructor, or block.If we access a static variable without the class name, the\ncompiler will automatically append the class name.Static variables cannot be\ndeclared locally inside an instance method.Static blocks can be used to initialize\nstatic variables.\nJava’s Selection statements:\n● if\n● if-else\n● nested-if\n● if-else-if\n● switch-case\n● jump – break, continue, return\nSimple : if statement is the most simple decision-making statement. It is used to\ndecide whether a certain statement or block of statements will be executed or not\ni.e if a certain condition is true then a block of statements is executed otherwise\nnot.\nif(condition)\n{\n// Statements to execute if\n// condition is true }\nif-else: The if statement alone tells us that if a condition is true it will execute a\nblock of statements and if the condition is false it won’t. But what if we want to do\nsomething else if the condition is false? Here comes the else statement. We can use\nthe else statement with the if statement to execute a block of code when the\ncondition is false.\nSyntax:\nif (condition)\n{\n// Executes this block if\n// condition is true\n}\nelse\n{\n// Executes this block if\n// condition is false\n}\nnested-if: A nested if is an if statement that is the target of another if or else.\nNested if statements mean an if statement inside an if statement. Yes, java allows\nus to nest if statements within if statements. i.e, we can place an if statement inside\nanother if statement.\nSyntax:\nif (condition1)\n{\n// Executes when condition1 is true\nif (condition2)\n{\n// Executes when condition2 is true\n}\n}\nif-else-if ladder: A user can decide among multiple options.The if statements are\nexecuted from the top down. As soon as one of the conditions controlling the if is\ntrue, the statement associated with that ‘if’ is executed, and the rest of the ladder is\nbypassed. If none of the conditions is true, then the final else statement will be\nexecuted. There can be as many as ‘else if’ blocks associated with one ‘if’ block\nbut only one ‘else’ block is allowed with one ‘if’ block.\nif (condition)\nstatement;\nelse if (condition)\nstatement;\n.\n.\nelse\nStatement;\nSwitch-case: The switch statement is a multiway branch statement. It provides an\neasy way to dispatch execution to different parts of code based on the value of the\nexpression.\nSyntax:\nswitch (expression)\n{\ncase value1:\nstatement1;\nbreak;\ncase value2:\nstatement2;\nbreak;\n. case valueN:\nstatementN;\nbreak;\ndefault:\nstatementDefault;\n}\nJump: Java supports three jump statements: break, continue and return. These\nthree statements transfer control to another part of the program.\nBreak: In Java, a break is majorly used for:\n● Terminate a sequence in a switch statement.\n● To exit a loop.\n● Used as a “civilized” form of goto.\nContinue: Sometimes it is useful to force an early iteration of a loop. That is, you\nmight want to continue running the loop but stop processing the remainder of the\ncode in its body for this particular iteration. This is, in effect, a goto just past the\nbody of the loop, to the loop’s end. The continue statement performs such an\naction.\nReturn: The return statement is used to explicitly return from a method,it causes\nprogram control to transfer back to the caller of the method.\nLoops in Java\nJava provides three ways for executing the loops.\nwhile loop: A while loop is a control flow statement that\nallows code to be executed repeatedly based on a given\nBoolean condition. The while loop can be thought of as a\nrepeating if statement.\nSyntax : while (boolean condition)\n{\nloop statements...\n}\nIt is also called Entry control loop.Once the condition is evaluated to true, the\nstatements in the loop body are executed and statements contain an update value\nfor the variable being processed for the next iteration.When the condition becomes\nfalse, the loop terminates which marks the end of its life cycle.\ndo while:-do while loop is similar to while loop with only difference that it checks\nfor condition after executing the statements, and therefore\nis an example of Exit Control Loop.\nSyntax: do {\nstatements..\n}\nwhile (condition);\ndo while loop starts with the execution of the\nstatement,there is no checking of any condition for the first\ntime.After the execution of the statements, and update of\nthe variable value, the condition is checked for true or false value. If it is evaluated\nto be true, the next iteration of the loop starts.When the condition becomes false,\nthe loop terminates which marks the end of its life cycle.\nfor:-for loop provides a concise way of writing the loop structure. Unlike a while\nloop, a for statement consumes the initialization, condition and\nincrement/decrement in one line .\nSyntax:\nfor (initialization condition; testing condition;increment/decrement)\n{\nstatement(s)\n}\nInitialization condition:-we initialize the variable in use. It marks the start of a for\nloop. An already declared variable can be used or a variable can be declared, local\nto loop only.\nTesting Condition: It is used for testing the exit\ncondition for a loop. It must return a boolean value.\nIt is also an Entry Control Loop as the condition is\nchecked prior to the execution of the loop\nstatements.\nStatement execution: Once the condition is\nevaluated to true, the statements in the loop body\nare executed.\nIncrement/ Decrement: It is used for updating the\nvariable for the next iteration.\nLoop termination:When the condition becomes\nfalse, the loop terminates marking the end of its life cycle.\nNested loop means a loop statement inside another loop statement.\nSyntax for Nested For loop:\nfor ( initialization; condition; increment )\n{\nfor ( initialization; condition; increment )\n{\n// statement of inside loop\n}\n// statement of outer loop\n}\nPROGRAMS:-\n1.Write a java program using a nested for loop to print a 2D matrix.\n2.Write a java program that uses a nested for loop to print all prime factors of a\nnumber.\n3.Write a java program that uses a nested for loop to print the following pattern.\n*\n* *\n* * *\n* * * *\nFor-each Version of for loop\nIt starts with the keyword for like a normal for-loop.Instead of\ndeclaring and initializing a loop counter variable, declare a variable that is the same\ntype as the base type of the array, followed by a colon, which is then followed by\nthe array name.In the loop body, the loop variable created rather than using an\nindexed array element. It is used to iterate over an array or a Collections class (eg,\nArrayList)\nSyntax: for (type var : array)\n{\nstatements using var;\n}\nThis for-loop provides another way for traversing the array or collections and\nhence it is mainly used for traversing arrays or collections. This loop also makes\nthe code more readable and reduces the chance of bugs in the code.\nclass ex1{\npublic static void main(String args[]){\nint arr[]={12,13,14,44};\nint total=0;\nfor(int i:arr){\ntotal=total+i;\n}\nSystem.out.println(\"Total: \"+total);\n}\n}\nArray\nAn array is a collection of items of same data type stored at\ncontiguous memory locations.Array in java is a group of like-typed variables\nreferred to by a common name.All arrays are dynamically allocated.Arrays are\nstored in contiguous memory locations.An array can contain primitives (int, char,\netc.) and object (or non-primitive) references of a class depending on the definition\nof the array. In the case of primitive data types, the actual values are stored in\ncontiguous memory locations.\nCreating an array\nOne-Dimensional Arrays: The general form of a one-dimensional array\ndeclaration is\ndatatype array-name[ ] =new datatype[size];\nOR\ndatatype[ ] array-name = new datatype[size];\ndataType - it can be primitive data types like int, char, double, byte, etc. or Java\nobjects\narrayName - it is an identifier.we can declare and allocate the memory of an array\nin one single statement.\nwe can initialize arrays during declaration. For example,\n//declare and initialize and array\nint[] age = {12, 4, 5, 2, 5};\nHere,Java compiler automatically specifies the size by counting the number of\nelements in the array.Arrays in Java can also initialize , using the index number.\nFor example,\n// declare an array\nint[] age = new int[5];\n// initialize array\nage[0] = 12; Array indices always start from 0. the first\nage[1] = 4; element of an array is at index 0.If the size of an array\nage[2] = 5; is n, then the last element of the array will be at index n-1.\nAccess Elements of an Array\nWe can access the element of an array using the index number.\nSyntax:-\n// access array elements\narray[index];\nclass Main {\npublic static void main(String[] args) {\n// create an array\nint[] age = {12, 4, 5, 2, 5};\n// access each array elements\nSystem.out.println(\"Accessing Elements of Array:\");\nSystem.out.println(\"First Element: \" + age[0]);\nSystem.out.println(\"Second Element: \" + age[1]);\nSystem.out.println(\"Third Element: \" + age[2]);\nSystem.out.println(\"Fourth Element: \" + age[3]);\nSystem.out.println(\"Fifth Element: \" + age[4]);\n}\n}\nclass Main {\npublic static void main(String[] args) {\n// create an array\nint[] age = {12, 4, 5};\n// loop through the array\n// using for loop\nSystem.out.println(\"Using for Loop:\");\nfor(int i = 0; i < age.length; i++){ the length property of the array to get\nSystem.out.println(age[i]); the size of the array.\n}\n}\n}\nThe for-each loop to iterate through the elements of an array.\nFor example,\nclass Main {\npublic static void main(String[] args) {\n// create an array\nint[] age = {12, 4, 5};\n// loop through the array\n// using for loop\nSystem.out.println(\"Using for-each Loop:\");\nfor(int a : age) {\nSystem.out.println(a);\n}\n}\n}\nMultidimensional Arrays\nA multidimensional array is an array of arrays.\nEach element of a multidimensional array is an\narray itself. For example,\ndata_type[][] array_name = new\ndata_type[x][y];\nint[][] a = new int[3][4];\nA multidimensional array named a is a\n2-dimensional array, that can hold a maximum of 12 elements,\nInitialize a 2-dimensional array in Java\nint[][] a = { {1, 2, 3}, {4, 5, 6, 9}, {7}, };\nExample:-\nimport java.util.*;\npublic class matrix1\n{\npublic static void main(String[] args) {\nScanner sc = new Scanner(System.in);\nSystem.out.print(\"Input total row : \");\nint row = sc.nextInt();\nSystem.out.print(\"Input total column : \");\nint column = sc.nextInt();\nint [][] matrix = new int[row][column];\nfor (int i = 0; i < row; i++)\n{\nfor(int j = 0; j < column; j++) {\nSystem.out.println(\"Row [\"+i+\"]: Column \"+j+\"\n:\");\nmatrix[i][j] = sc.nextInt();\n}\n}\nfor (int i = 0; i < row; i++)\n{\nfor(int j = 0; j < column; j++) {\nSystem.out.print(matrix[i][j] +\" \");\n}\nSystem.out.println();\n}\n}\n}\nCommand Line Arguments The command-line arguments in Java allow passing\narguments during the execution of the program.Here arguments are passed through\nthe command line.\nclass Main {\npublic static void main(String[] args) {\nSystem.out.println(\"Name of the college is\");\n// loop through all arguments\nfor(String str: args) {\nSystem.out.println(str);\n}\n}\n}\nAfter that, compile and run the above program.we want to pass some arguments\nwhile running the program, we can pass the arguments after the class name.\nFor example,\njava Main Nirmala College Meloor\nHere Nirmala College and Meloor are arguments passed to the program through\nthe command line\nThe output will be\nName of the college is\nNirmala\nCollege\nMeloor\nThe main() method includes an array of strings named args as its parameter.The\nString array stores all the arguments passed through the command line.\nPassing Numeric Command-Line Arguments\nThe main() method of every Java program only accepts string arguments. To pass\nnumeric arguments through the command line we can convert string arguments\ninto numeric values.\nclass Main {\npublic static void main(String[] args) {\nfor(String str: args) {\n// convert into integer type\nint argument = Integer.parseInt(str);\nSystem.out.println(\"Argument in integer form: \" + argument);\n} } }\nCompile and run the above code and enter the values as arguments\njava Main 11 23\nThe output will be\nArgument in integer form: 11\n23\nint argument = Integer.parseInt(str);\nThe above parseInt() method of the Integer class converts the string argument into\nan integer. By using the parseDouble() and parseFloat() method to convert the\nstring into double and float respectively.\nClass-user defined data type\nA class is a group of objects which have common properties.\nA Class in Java can contain:\n● Data member\n● Method\n● Constructor\n● Nested Class\n● Interface\nDeclare Class in Java\naccess_modifier class <class_name>\n{\ndata member;\nmethod;\nconstructor;\nnested class;\ninterface;\n}\nExample:-\nClass empty\n{\n}\nHere the class is empty, this class does not contain any properties and therefore\ncannot do anything.\nExample:-class with instance variables or member variables\nClass rectangle\n{\nint length ;\nint width;\n}\nMethod\nMethods are declared inside the body of the class but immediately after the\ndeclaration of instance variables.\nClass rectangle\n{\nint len,width;\nvoid getData(){\n}\nvoid rectArea(){\n}\n}\nMethod declarations have 6 components:\n1. Modifier: It defines the access type of the method i.e. from where it can be\naccessed in your application. In Java, there are 4 types of access specifiers.\n● public: It is accessible in all classes .\n● protected: It is accessible within the class in which it is defined and in its\nsubclass/es\n● private: It is accessible only within the class in which it is defined.\n● default: It is declared/defined without using any modifier. It is accessible\nwithin the same class and package within which its class is defined.\n2. The return type: The data type of the value returned by the method or void if\ndoes not return a value. It is Mandatory in syntax.\n3. Method Name: the rules for field names apply to method names , but the\nconvention is little different\n4. Parameter list: Comma-separated list of the input parameters is defined,\npreceded by their data type, within the enclosed parentheses. If there are no\nparameters, we must use empty parentheses ().\n5. Exception list: The exceptions you expect by the method can throw, we can\nspecify these exception(s).\n6. Method body: It is enclosed between braces. The code we need to be executed\nto perform our intended operations.\nMethod Signature:-\nThe method name along with the list of parameters used in the method\nprototype is known as method signature. It is part of the method prototype.\nMethod prototype is public int max(int x,int y)\nMethod signature is max\n● The access modifier public signifies that the method can be accessed by\nother classes.\n● The return type is int which signifies that the method returns a value of int\ndata type.\n● The parameter list has two parameters ; data types of both parameters are int\nand the name of the identifiers are x and y.\nDeclaring a Java Method\n1.Method with no arguments and return type\nThe syntax to declare a method is:\nreturnType methodName() {\n// method body\n}\nreturnType - It specifies what type of value a method returns.\nFor example if a method has an int return type then it returns an integer value.\nIf the method does not return a value, its return type is void.\nmethodName - It is an identifier that is used to refer to the particular method in a\nprogram.\nmethod body - It includes the programming statements that are used to perform\nsome tasks. The method body is enclosed inside the curly braces { }.\nFor example,\nint addNumbers() {\n// code\n}\nIn the above example,\n● The name of the method is adddNumbers().\n● The return type is int.\npublic class Calculator\n{\nint num1, num2;\npublic int Add()\n{\nint result;\nresult = num1 + num2;\n}\npublic int Sub()\n{\nint result;\nresult= num1 - num2;\n}\n}\nThe above class, Calculator, is a user-defined data type (as it is defined by the\nuser) which can use a collection of two primitive data type variables - int num1 and\nnum2. Thus, the class Calculator is a composite data type. Variable num1 and\nnum2 are called its member variables.\nThe Calculator class has two member methods - Add() and Sub().\n● The member method Add() provides the functionality to add two numbers,\n● The member method Sub() provides the functionality to subtract two\nnumbers.\nCreating Objects of the Class\nThe new operator is used to create an object of the Calculator class\nCalculator myCalculator = new Calculator();\nmyCalculator object is a\n● variable of Calculator data type\n● reference type as it stores reference to the memory location where the\nobject is stored.\nAccessing Member Variables\nAfter creating an object (or instance), its member variables can be accessed\nvia the dot (.)operator. For example, a member variable num1 can be accessed as\nmyCalculator.num1. we can access member variable num2 as\nmyCalculator.num2.\nValues can be assigned to member variables as follows\nmycalculator.num1 = 9;\nmycalculator.num2=8;\nAccessing Member Methods\nIn order to invoke the addition operation,\nmyCalculator.Add(); is used.\n/* Calculator.java */ 2\npublic class Calculator{\nint num1, num2;\npublic int Add(){\nint result;\nresult= num1+num2;\nreturn result;\n}\npublic int Sub(){\nint result;\nresult =num1 - num2;\nreturn result;\n}\npublic static void main(String args[])\n{\nint sum, diff;\nCalculator myCalculator =new Calculator();\nmyCalculator.num1 = 9;\nmyCalculator.num2 = 8;\nsum =myCalculator.Add();\ndiff= myCalculator.Sub();\nSystem.out.println(\"Sum is: \" + sum);\nSystem.out.println(\"Difference is: \" + diff);\n}\n}\n2.Method without Parameters and Without Return Type.\nimport java.util.Scanner;\npublic class Rectangle\n{\nint length, width;\nint area, perimeter;\ndouble diagonal;\n}\npublic void AcceptInput(){\nScanner keyboard= new Scanner(System.in);\nSystem.out.print(\"Enter length: \");\nlength = keyboard.nextInt();\nSystem.out.print(\"Enter width: \");\nwidth= keyboard.nextInt();\n}\npublic void Compute()\n{\narea= length * width;\nperimeter = 2 *(length +width);\ndiagonal = Math.sqrt(length * length + width * width);\n}\npublic void DisplayData()\n{\nSystem.out.println(\"The area of rectangle is: \" + area);\nSystem.out.println(\"The perimeter of rectangle is: \" + perimeter);\nSystem.out.println(\"The diagonal of rectangle is: \" + diagonal);\n}\npublic static void main(String args[])\n{\nRectangle myRectangle = new Rectangle();\nmyRectangle.AcceptInput();\nmyRectangle.Compute();\nmyRectangle. DisplayData();\n}\n}\n3.Methods with parameters and return type\nThe complete syntax of declaring a method is\nmodifier static returnType nameOfMethod (parameter1, parameter2, ...) {\n// method body\n}\nmodifier - It defines access types whether the method is public, private, and so on.\nstatic - If we use the static keyword, it can be accessed without creating objects.\nFor example, the sqrt() method of standard Math class is static. Hence, we can\ndirectly call Math.sqrt() without creating an instance of Math class.\nparameter1/parameter2 - These are values passed to a method. We can pass any\nnumber of arguments to a method.\nCalling a Method in Java\n// calls the method\naddNumbers();\nCall a method in Java using the name the method followed by a parenthesis\nclass Main {\n// create a method\npublic int addNumbers(int a, int b) {\nint sum = a + b;\n// return value\nreturn sum;\n}\npublic static void main(String[] args) {\nint num1 = 25;\nint num2 = 15;\n// create an object of Main\nMain obj = new Main();\n// calling method\nint result = obj.addNumbers(num1, num2);\nSystem.out.println(\"Sum is: \" + result);\n}\n}\nActual parameters and Formal Parameters\n● The parameters that appear in the method invocation are called actual\nparameters\n● The parameters that appear in the method definition are called formal or\ndummy parameters\nSometimes, the method call statement may contain an expression as an\nargument. In such cases, the actual parameters in the method call statement\nare first used to evaluate the expression, and the values are then assigned to\nthe formal parameters in the method definition. Using these values, the body\nof the method is executed. For example,a call statement, such as:\nc=sum(2,7);\nIn this case, the expression sum(2,7) will be evaluated first using the actual\nparameter. Its value will then be assigned to the formal parameter p, and the\nq and body of the sum() method will be executed. .\nReturning from Methods\nThe program control transfers to the invoked method. Once the method\nexecution finishes, the control transfers back to the invoking statement.\nThere are two ways in which the control can transfer back. The return\nstatement is encountered in the invoked method.The last statement in the\ninvoked method is executed.\nThe Return Statement\nThe methods you create process some data and give a calculated value.\nThe calculated value remains within the method unless it is returned back to\nthe invoking method. Such methods specify the return value via the return\nstatement. The syntax of the return statement is:\nreturn expression;\nThe return statement can only be used inside the method body. The data type\nof the return value must match the type specified in the method header.\npublic class ComputeCubeDemo\n{\npublic int FindCube(int x)\n{\nint result;\nresult = x *x*x; //data type of the return value must match the type\nreturn result; specified in the method header\n}\npublic void ComputeCube()\n{\nint num = 5;\nint myResult;\nmyResult = FindCube(num);\nSystem.out.println (\"Cube of\" + num+\" is” + myResult);\n}\n}\nPassing Values to Methods:-\nIt receives the arguments passed from the calling method, performs the\nnecessary operations and returns the control back to the calling method.\nI. We can pass two types of arguments to the Java method:\n● any primitive data types, i.e., char, byte, short, int, long, float, double,\nand boolean\n● reference data types, i.e., objects or arrays\nII. can pass values to a method in two ways:\n● pass by value (call by value)\n● pass by reference,(call by reference)\nPass by Value (Call by Value)\nWhen parameters are passed to a method by value, the values\nof actual parameters are copied to the formal parameters. Hence, the called\nmethod creates its own copy of the argument values and uses them. By doing\nso, any change in the formal parameter values does not reflect in the actual\nparameters. Thus, the actual parameter values remain the same.\nPass by Reference (Call by Reference)\nIn the pass by reference technique, the reference of the actual parameter\nis passed to the formal parameter. The reference denotes the memory\nlocation of a variable. As a result, both the actual parameter and the formal\nparameter represent the same memory location. Hence, the called method\nworks with the original data rather than its own copy. Thus, any changes\nmade to the value of the formal parameter also get reflected in the actual\nparameter.\n4.Methods with arguments and no return type:-\nFunction without return type stands for a void function. The void function\nmay take multiple or zero parameters and return nothing. Here, we are going\nto define a method which takes 2 parameters and doesn’t return anything.\nExample:-\nimport java.util.*;\npublic class Main {\npublic static void main(String args[])\n{\nint a = 4;\nint b = 5;\n// Calling the function with 2 parameters\ncalc(a, b);\n}\npublic static void calc(int x, int y)\n{\nint sum = x + y;\n// Displaying the sum\nSystem.out.print(\"Sum of two numbers is :\" + sum);\n}\n}\nMethod Overloading:-\nThe process of defining two or more methods with the same name but\ndifferent signatures in a class is called method overloading.It is possible in\nJava to define two or more methods within the same class that have the same\nname and parameter declarations are different. These methods are said to be\noverloaded, and the process is referred to as method overloading,by which\nJava implements polymorphism. Consider\nmax(int num1, int num2);\nmax(double num1, double num2);\nThe above-mentioned two methods have the same name but different\nparameter declarations. If we call max() with int parameters, the max()\nmethod that expects int parameters will be invoked. If we call max() with\ndouble parameters, the max() method that expects double parameters will be\ninvoked. This is referred to as method overloading, and the method max() is\nsaid to be overloaded.\nNeed for Method Overloading\nThe behavior of an object is implemented through methods in a class.\nSometimes, an object is intended to perform similar operations with slight\nchange in the parameters.\nDefining Overloaded Methods:-\nThe method name along with the list of parameters in the method prototype\nis known as method signature.\nFor example, consider the following method heading:\npublic int compute(int num, double dbl, String name)\nIts signature is:\ncompute(int num, double dbl, String name)\nThe return type of the method is not a part of the method signature.\nIf two methods have the same type and number of arguments in the same\norder, they have the same signature.\nExample, consider the following two method signatures:\nmax(int x, int y);\nmax(int n, int m);\nIn Java, we can overload a method, provided the methods with the same\nname have different signatures. The signature to have the same signatures\neven though they are using different parameter variable names can differ in\nthe type of parameters or in the number of parameters or both.\nThese methods are said When a method has been declared more than once in\na class, Java uses the following steps as its guide to determine the\noverloading:\ni. If the signature of a method matches with that of the previous method,\nthen that method is treated as a redeclaration of the first method.\nii. If the signatures of the two methods match but differ in their return types,\nthe second declaration is flagged as: syntax error.\niii. If the signature of the two methods differing the type of parameters or in\nthe number of parameters or both the two methods are considered as\noverloaded\n/* OverloadingMethods.java */\npublic class OverloadingMethods\n{\n//find the maximum of two double values\npublic static int max(int num1, int num2) //find the maximum of two int\nvalues\n{\nif (num1 > num2)\nreturn num1;\nelse\nreturn num2;\n}\n//find the maximum of two double values\npublic static double max(double num1, double num2)\n{\nif (num1 > num2)\nreturn num2;\nelse\nreturn num1;\n}\n//find the maximum of three double values\npublic static double max(double num1, double num2, double num3)\n{\nreturn max(num1, max(num2, num3));\n}\npublic static void main(String[] args)\n{\nSystem.out.println(\"Invoking the max() method with int values 11 and 13\");\n//Invoked with two int values.\nSystem.out.println(\"Maximum value is: \" + max(11, 13));\nSystem.out.println(\"Invoking the max() method with double values 21.3 and\n20.9\");\n//Invoked with two double values.\nSystem.out.println(\"Maximum value is: \" + max(21.3, 20.9));\nSystem.out.println(\"Invoking the max() method with three double values\n33.3,33.7,33.0”);\n//Invoked with three double values.\nSystem.out.println(\"Maximum value is: \" + max(33.3,33.7,33.0));\n}\n}\nOUTPUT\nConstructors and their Use\nA constructor is a member method of a class that is used to initialize the\ninstance variables. Below Statement that creates an object:\nStudent student = new Student();\nThe above statement creates a new object called student of the Student\nclass type. The code following the new keyword acts as a method call. In\nfact, it is a call to a special kind of method called a constructor. Every class\nhas at least one constructor method. The purpose of a constructor is to create\nan instance of the class. The new operator creates an empty object of the\ngiven class and then calls the constructor method, which can initialize the\ninstance variables of the object.\nclass Student //Class name\n{\nint rollNumber;\nchar grade;\npublic Student() //Constructor\n{\nrollNumber = 17;\ngrade = 8;\n}\n//statement1\n//statement2\n}\nCharacteristics of the constructor:\n● Constructors are invoked implicitly when you instantiate objects.\n● The two rules for creating a constructor are:\n● The name of the constructor should be the same as the class.\n● A Java constructor must not have a return type.\n● If a class doesn't have a constructor, the Java compiler automatically\ncreates a default constructor during run-time. The default constructor\ninitializes instance variables with default values. For example, the int\nvariable will be initialized to 0\n● A constructor cannot be abstract or static or final.\n● A constructor can be overloaded but can not be overridden.\n● The constructor method does not have a return type- not even void.\n● The constructor can be invoked only via the new operator.\nTypes of Constructors\nThere are two types of constructors in Java\n1.Default Constructor\nThe class name followed by parentheses specifies a constructor for\nthe class. The constructor defines what happens when an object of the class\nis created.It is not compulsory to define the constructor explicitly in the\nclass. No constructor has been defined for the class, then the Java compiler\nautomatically includes a default constructor. The default constructor is a\nconstructor that does not accept any arguments and has no statements in its\nbody.\nClass Student //Class name\n{\nint rollNumber;\nChar grade;\npublic Student() //Default Constructor\n{\nNo Statements in its body\n//statement1\n//statement2\n}\n}\nOnce a programmer has added a constructor to the class, no default\nconstructor will be added by the compiler. A constructor that does not\ncontain any parameters is called a non-parameterised constructor.\n/Student2.java */\nclass Student2 //Class name Constructor defined in the class with the\n{ same name as the class name. It initializes the\nint rollNumber; member variables.\nchar grade;\n}\npublic Student2() //Constructor\n{\nSystem.out.println(\"Inside Constructor\");\nrollNumber= 17;\ngrade = 'Z';\n}\npublic void DisplayData() OUTPUT\n{\nSystem.out.println(\"Roll Number: \" +\nrollNumber);\nSystem.out.println(\"Grade: \" + grade);\n}\npublic static void main(String args[])\n{\nStudent2 student2 = new Student2();\nstudent2.DisplayData();\n}\n2. Parameterised Constructor\nA constructor with parameters is called a parameterised constructor. The\nparameterised constructor allows the programme to initialize objects with\ndifferent values. This is achieved by passing the required values as\narguments to the construct method.\n/* Student3.java */\nclass Student3 //Class name 3 Constructor defined in the class with the\n{ same name as the class name.It\nint rollNumber; initializes the member variables with\nchar grade; the argument values\npublic Student3(int roll, char grd)\n{\nSystem.out.println(\"Inside Constructor\");\nrollNumber= roll;\ngrade =grd;\n}\npublic void DisplayData()\n{\nSystem.out.println(\"Roll Number: + rollNumber);\nSystem.out.println(\"Grade: grade);\n}\npublic static void main(String args[])\n{\nStudent 3 studentA = new Student3(23,\n'D');\nstudentA.DisplayData();\nStudent3 students = new Student3(27, 'A');\nstudent3.DisplayData();\n} Constructor was invoked when the\n} object was created, and initialized the member\nvariables with the argument values\n3.Copy Constructor:-\nJava copy constructor is a particular type of constructor that is used to\ncreate a duplicate (exact copy) of the existing object of a class. Copy\nconstructors create and return a new object using the existing object of a\nclass.\nExample:-\npublic class Fruit\n{\nprivate double fprice;\nprivate String fname;\n//constructor to initialize price and name of the fruit\nFruit(double fPrice, String fName)\n{\nfprice = fPrice;\nfname = fName;\n}\n//creating a copy constructor\nFruit(Fruit fruit)\n{\nSystem.out.println(\"\\nAfter invoking the Copy Constructor:\\n\");\nfprice = fruit.fprice;\nfname = fruit.fname;\n}\n//creating a method that returns the price of the fruit\ndouble showPrice()\n{\nreturn fprice;\n}\n//creating a method that returns the name of the fruit\nString showName()\n{\nreturn fname;\n}\n//class to create student object and print roll number and name of the student\npublic static void main(String args[])\n{\nFruit f1 = new Fruit(399, \"Ruby Roman Grapes\");\nSystem.out.println(\"Name of the first fruit: \"+ f1.showName());\nSystem.out.println(\"Price of the first fruit: \"+ f1.showPrice());\n//passing the parameters to the copy constructor\nFruit f2 = new Fruit(f1);\nSystem.out.println(\"Name of the second fruit: \"+ f2.showName());\nSystem.out.println(\"Price of the second fruit: \"+ f2.showPrice());\n}\n}\nOutput:\nName of the first fruit: Ruby Roman Grapes\nPrice of the first fruit: 399.0\nAfter invoking the Copy Constructor:\nName of the second fruit: Ruby Roman Grapes\nPrice of the second fruit: 399.0\nConstructor overloading\nThe process of creating more than one constructor with the same\nname but with the different parameter declaration is called constructor\noverloading.The signature of all versions of the constructor should be\ndifferent for the constructor overloading purpose; they should have different\ntypes of parameters or different number of parameters or both.\nExample Program:-\n/*Cuboid.java */\npublic class Cuboid //Class name\n{\nint length;\nint width;\nint height;\n//Constructor without any parameter\npublic Cuboid()\n{\nSystem.out.println(\"Invoking constructor with no parameters\");\nlength =20;\nwidth = 15;\nheight = 10;\n}\n//Constructor with one parameter\npublic Cuboid(int len)\n{\nSystem.out.println(\"Invoking constructor with one parameter\nlength= len;\nwidth=15;\nheight 10;\n}\n//Constructor with two parameters\npublic Cuboid(int len, int wd)\n{\nSystem.out.println(\"Invoking constructor with two parameters\");\nlength= len;\nwidth = wd;\nheight = 10;\n}\n//Constructor with three parameters\npublic Cuboid(int len, int wd, int ht)\n{\nSystem.out.println(\"Invoking constructor with three parameters\nlength = len;\nwidth = wd;\nheight = ht;\n}\nvoid Volume()\n{\nint volume;\nvolume = length * width * height;\nSystem.out.println(\"Dimensions of the cuboid are:\");\nSystem.out.println(\"Length: \" + length);\nSystem.out.println(\"Width: + width);\nSystem.out.println(\"Height: \" + height);\nSystem.out.println(\"Volume of the cuboid is: \" + volume);\nSystem.out.println();\n}\npublic static void main(String args[])\n{\nCuboid cuboid1 = new Cuboid();\ncuboid1. Volume();\nCuboid cuboid2 = new Cuboid (50);\ncuboid2. Volume();\nCuboid cuboid3 = new Cuboid(102,40);\ncuboid3. Volume();\nCuboid cuboid4 = new Cuboid(46,30,14); OUTPUT\ncuboid4. Volume();\n}\n}\nDifference between constructors\nand methods\nCONSTRUCTOR METHOD\nThe constructor name must be the The method name must be\nsame as the class name different from the class name\nA constructor has no return type A method must have a return type\nnot even void if it does not return a value it\nmust return void\nConstructors are called only via Methods can be called directly by\nthe new operator at the time of an object that has already been\nobject creation ,cannot invoke created the method calls are\nthem as normal method calls specified by the programmer\nExecution of at least one constructor is a All the methods defined in a class may\nmust when an object of the class is or may not be execute depending on the\ncreated calls specified by the programmer\nSTATIC KEYWORD\nIf we want to access class members without creating an instance of the class, we\nneed to declare the class members static.This keyword helps in saving a lot of\nmemory and getting the memory at the time of loading the class.It is basically used\nwith methods and variables to indicate that it is a part of the class, not the object.\nIn every Java program, we have declared the main method static,because to run the\nprogram the JVM should be able to invoke the main method during the initial\nphase where no objects exist in the memory.\nSTATIC METHODS\nStatic methods are also called class methods. It is because a static method belongs\nto the class rather than the object of a class and can invoke static methods directly\nusing the class name.\nclass Test {\n// static method inside the Test class\npublic static void method() {...}\n}\nclass Main {\n// invoking the static method\nTest.method();\n}\nSTATIC VARIABLES\nIf a variable is declared as static, all objects of the class share the same static\nvariable. It is because like static methods, static variables are also associated with\nthe class. And, we don't need to create objects of the class to access the static\nvariables. For example,\nclass Test {\n// static variable\nstatic int age;\n}\nclass Main {\n// access the static variable\nTest.age = 20;\n}\nSTATIC BLOCKS\nStatic blocks are used to initialize the static variables.The static block is executed\nonly once when the class is loaded in memory. The class is loaded if either the\nobject of the class is requested in code or the static members are requested in code.\nA class can have multiple static blocks and each static block is executed in the\nsame sequence in which they have been written in a program.\nclass Main {\n// static variables\nstatic int a = 23;\nstatic int b;\nstatic int max;\n// static blocks\nstatic {\nSystem.out.println(\"First Static block.\");\nb = a * 4;\n}\nstatic {\nSystem.out.println(\"Second Static block.\");\nmax = 30;\n}\n// static method\nstatic void display()\n{\nSystem.out.println(\"a = \" + a);\nSystem.out.println(\"b = \" + b); OUTPUT\nSystem.out.println(\"max = \" + max);\n}\npublic static void main(String args[]) {\n// calling the static method\ndisplay();\n}\n}\nNested Static Class\nIn Java, we can declare a class inside another class. Such classes are known as\nnested classes.A class can be made static only if it is a nested class. Nested static\nclass doesn‘t need a reference of Outer class. Nested classes are of 2 types:\n● Static Nested Classes\n● Non-static Nested Classes\nFor example,\nclass OuterClass {\n// static nested class\nstatic class NestedClass {...}\n// non-static nested class\nclass InnerClass {...}\n}\nFINAL KEYWORD\nThe final keywords are used with methods, variables and classes. When the final\nkeyword is utilized with a variable of primitive data types, we cannot modify the\nvalue.\n● The final variable cannot be reinitialized with another value\n● The final method cannot be overridden\n● The final class cannot be extended\nJava final Variable\nclass Main {\npublic static void main(String[] args)\n{\n// create a final variable\nfinal int AGE = 32;\n// try to change the final variable\nAGE = 45;\nSystem.out.println(\"Age: \" + AGE);\n}\n}\nWhen the above code is executed the error message will display because AGE is a\nfinal variable .In the next line the value of AGE is trying to be initialized with\nanother value which will result in an error.\nIt is recommended to use uppercase to declare final variables in Java.\nThe this keyword\nWithin a constructor or a method this is a reference to the current object -the\nobject whose constructor or method is being invoked.\nclass Area\n{\nint length, breadth;\npublic Area(int length, int breadth)\n{\nlength length;\nbreadth = breadth;\n} Inside the constructor, length, and breadth are local variables\npublic void Display()\n{\nint area = length breadth;\nSystem.out.println(\"Area is \" + area);\n}\npublic static void main(String args [ ])\n{\nArea area=new area(2,3);\narea.display();\n}\n}\nThe output of the program is zero. Because both the parameter variables and\ninstance variables have the same name length and breadth. Therefore, the value of\nthe parameter is actually assigned to the parameter value itself.\nparameter variable length = parameter variable length;\nThis resulted in an area equal to zero.\nAreaNew.java */\nclass AreaNew\n{\nint length, breadth;\npublic AreaNew(int length, int breadth)\n{\nthis.length= length; The this keyword is used to assign values to the\nthis.breadth= breadth; instance variables\n}\npublic void Display()\n{\nint area length breadth;\nSystem.out.println(\"Area is + area);\n}\npublic static void main(String args[]) Output\n{ Area is 6\nAreaNew area = new AreaNew(2, 3);\narea.Display();\n}\nHere this keyword is used to refer to the instance variable instead of the argument\nvariable.\nGarbage Collection\nIn some languages like C++,dynamically allocated objects must be manually\nreleased by use of a delete operator.\nJava handles deallocation automatically.The technique that accomplishes this, is\ncalled garbage collection.When no references to an object exist,that object is\nassumed to be no longer needed and the memory occupied by the object can be\nreclaimed.Garbage collection only occur infrequently during the execution of a\nprogram.It will not occur simply because one or more objects exist that are no\nlonger used.\nThe finalize() Method in Java\nSometimes an object will need to perform some actions when it is\ndestroyed.The finalize() method is a non-static and protected method of\njava.lang.Object class.finalize() method in Java is used to release all the resources\nused by the object before it is deleted/destroyed by the Garbage collector.Java\nVirtual Machine(JVM) permits invoking of finalize() method only once per object.\nFor example, if an object is holding some non java resource such as a file handle or\ncharacter font ,then it might want to make sure that these resources are freed before\nan object is destroyed.To handle such situations , java provides a mechanism called\nfinalization.\nBy using finalization, we can define specific actions that will occur when an object\nis just about to be reclaimed by the garbage collector.\nTo add a finalizer to a class ,simply define the finalize() method.The java runtime\ncalls that method whenever it is about to recycle an object of that class.\nprotected void finalize()\n{\n//finalization code\n}\nNested and Inner Classes\nIt is possible to define a class within another class; such classes are known as\nnested classes.\nThe scope of a nested class is bounded by. the scope of its enclosing class. Thus, if\nclass B is defined within class A, then B does not exist independently of A. A\nnested class has access to the members, including private members, of the class in\nwhich it is nested.\nThe enclosing class does not have access to the members of the nested\nclass. A nested class that is declared directly within its enclosing class scope is a\nmember of its enclosing class.\nThere are two types of nested classes:\nstatic and non-static.\nA static nested class is one that has the static modifier applied. Because it is\nstatic, it must access the members of its enclosing class through an object. That is,\nit cannot refer to members of its enclosing class directly. Because of this\nrestriction, static nested classes are seldom used.\nThe most important type of nested class is the inner class.\n● An inner class is a non-static nested class.\n● It has access to all of the variables and methods of its outer class and may\nrefer to them directly in the same way that other non-static members of the\nouter class do.\n// Demonstrate an inner class\nclass Outer {\nint outer_x = 100;\nvoid test() {\nInner inner = new Inner();\ninner.display(); } // this is an inner class\nclass Inner {\nvoid display() {\nSystem.out.printIn(\"display: outer x =\" + outer _x);\n}\n}\n}\nclass InnerClassDemo { OUTPUT\npublic static void main(String args[]) { display: outer_x = 100\nOuter outer = new Outer();\nouter.test();\n}\n}\nInheritance\nInheritance in Java is a mechanism in which one object acquires all the properties\nand behaviors of a parent object.\nThe idea behind inheritance in Java is that\nwe can create new classes that are\nbuilt upon existing classes.\nWhen you inherit from an existing class, we can reuse methods and fields of the\nparent class.\nIn the terminology of Java, a class that is inherited is called a superclass.\nThe class that does the inheriting is called a subclass. Therefore, a subclass(derived\nclass) is a specialized version of a superclass(base class).\nIt inherits all of the instance variables and methods defined by the superclass and\nadds its own, unique elements.\nTypes of Inheritance in Java\nSome terms related to inheritance\n● Subclass: The class that inherits the attributes and methods of another class.\n● Superclass: The class whose attributes and methods the subclass inherits.\n● Extends: The subclass uses the keyword to inherit the superclass.\n● Reusability: The methods and attributes of the superclass can be reused in\nthe subclass because of inheritance, this is called reusability.\nExample:-\nclass ncas {\nvoid Nirmalacollege() {\nSystem.out.println(\"I am a super college\");\n}\n}\n// Inheriting SuperClass to SubClass\nclass csdept extends ncas{\nvoid methodcsdept() {\nSystem.out.println(\"I am a department of Nirmala college\\n\");\n}\n}\nclass Main {\npublic static void main(String args[]) {\ncsdept s1 = new csdept();\ns1.methodcsdept();\ns1.Nirmalacollege();\n}\n}\nThere are five different types of inheritances that are possible in Object-Oriented\nProgramming.\n● Single Inheritance\n● Multilevel Inheritance\n● Hierarchical Inheritance\n● Multiple Inheritance\n● Hybrid Inheritance\n1. Single Inheritance\nIn single inheritance, subclasses inherit the features of\none superclass. In the image below, class A serves as a\nbase class for the derived class B.\nExample:-\nclass ncas {\nvoid Nirmalacollege() {\nSystem.out.println(\"I am a super college\");\n}\n}\n// Inheriting SuperClass to SubClass\nclass csdept extends ncas{\nvoid methodcsdept() {\nSystem.out.println(\"I am a department of Nirmala college\\n\");\n}\n}\nclass Main {\npublic static void main(String args[]) {\ncsdept s1 = new csdept();\ns1.methodcsdept();\ns1.Nirmalacollege();\n}\n}\n2.Multilevel Inheritance\nIn Multilevel Inheritance, a derived class will be inheriting a base class, and as well\nas the derived class also acts as the base class for other classes.\nThe class A serves as a base class for the derived class B, which in turn serves as a\nbase class for the derived class C.\nExample:-\nclass Nirmala{\nvoid methodnirmala()\n{\nSystem.out.println(\"NIRMALA COLLEGE\\n\");\n} }\nclass csdept extends Nirmala{\nvoid cs(){System.out.println(\"COMPUTER SCIENCE\\n\");}\n}\nclass mmdept extends csdept{\nvoid methodmm(){System.out.println(\"MULTIMEDIA DEPARTMENT\");}\n}\nclass NCAS{\npublic static void main(String args[]){\nmmdept d=new mmdept();\nd.methodnirmala();\nd.cs();\nd.methodmm();\n}}\n3. Hierarchical Inheritance\nIn Hierarchical Inheritance, one class\nserves as a superclass (base class) for\nmore than one subclass. In the below\nimage, class A serves as a base class for\nthe derived classes B, C, and D.\nclass Nirmala{\nvoid methodnirmala()\n{\nSystem.out.println(\"NIRMALA COLLEGE\\n\");\n} }\nclass csdept extends Nirmala{\nvoid cs(){System.out.println(\"COMPUTER SCIENCE\\n\");}\n}\nclass mmdept extends Nirmala{\nvoid methodmm(){System.out.println(\"MULTIMEDIA DEPARTMENT\");}\n}\nclass fddept extends Nirmala{\nvoid methodfd(){System.out.println(\"FASHION DESIGNING DEPARTMENT\");}\n}\nclass NCAS{\npublic static void main(String args[]){\ncsdept c=new csdept();\nc.methodnirmala();\nc.cs();\nmmdept m=new mmdept();\nm.methodnirmala();\nm.methodmm();\nfddept f=new fddept();\nf.methodnirmala();\nf.methodfd();\n}}\n4. Multiple Inheritance (Through Interfaces)\nIn Multiple inheritances, one class can have more\nthan one superclass and inherit features from all\nparent classes. Java does not support multiple\ninheritances with classes. In Java, we can achieve\nmultiple inheritances only through Interfaces.\nClass C is derived from interfaces A and B.\nAn interface in Java is a blueprint of a class. It has static constants and abstract\nmethods.\nThe interface in Java is a mechanism to achieve abstraction. There can be only\nabstract methods in the Java interface, not method body. It is used to achieve\nabstraction and multiple inheritance in Java.\nExample:-\ninterface Bank{\nfloat rateOfInterest();\n}\nclass SBI implements Bank{\npublic float rateOfInterest(){return 9.15f;}\n}\nclass PNB implements Bank{\npublic float rateOfInterest(){return 9.7f;}\n}\nclass TestInterface2{\npublic static void main(String[] args){\nBank b=new SBI();\nSystem.out.println(\"ROI: \"+b.rateOfInterest());\n}}\nExtending interface\nOne interface can extend another interface The extends keyword is used to\nextend an interface, and the child interface inherits the methods of the parent\ninterface.\ninterface vehicle\n{\nvoid set();\n}\nInterface car extends vehicle\n{\nvoid show();\n}\nclass Test implements car\n{\npublic void set() {}\npublic void show() {}\n}\nProgram Implementing multiple Inheritance\nWe can implement multiple inheritance in Java using Interface\n// CNG Car interface\ninterface CNG_Car{\n// Abstract methods\nvoid drive();\nvoid cng_kit();\n}\n// Petrol Car interface\ninterface Petrol_Car{\n// Abstract methods\nvoid drive();\nvoid petrol_kit();\n}\n// Multiple Inheritance using Interface\nclass Hybrid_Car implements Petrol_Car, CNG_Car {\npublic void drive(){\nSystem.out.println(\"Driving a Hybrid Car\");\n}\n// Overridden method of CNG_Car Interface\npublic void cng_kit(){\nSystem.out.println(\"Using the CNG kit for Hybrid Car\");\n}\n// Overridden method of Petrol_Car Interface\npublic void petrol_kit(){\nSystem.out.println(\"Using the Petrol kit\nfor Hybrid Car\");\n}\n}\n// Driver Code\nclass Main {\npublic static void main(String args[]) {\n// Creating a new object of the Hybrid Car class\nHybrid_Car obj = new Hybrid_Car();\n// Calling the methods of the Hybrid_Car class\nobj.drive();\nobj.cng_kit();\nobj.petrol_kit();\n}\n}\n5. Hybrid Inheritance\nIt is a mix of two or more of the above types of inheritance. Since Java doesn’t\nsupport multiple inheritances with classes, hybrid inheritance is also not possible\nwith classes. In Java, we can achieve hybrid inheritance only through Interfaces.\nclass Nirmala\n{\npublic void disp()\n{\nSystem.out.println(\"Nirmala\");\n}\n}\nclass deptcs extends Nirmala\n{\npublic void disp()\n{\nSystem.out.println(\"Computer science\");\n}\n}\nclass deptmm extends Nirmala\n{\npublic void disp()\n{\nSystem.out.println(\"Multimedia\");\n}\n}\nclass deptfd extends deptcs\n{\npublic void disp()\n{\nSystem.out.println(\" Nirmala college \\n Fashion design\");\n}\npublic static void main(String args[]){\ndeptfd obj = new deptfd();\nobj.disp();\n}\n}\nSuper Keyword in Java\nThe super keyword in Java is used in subclasses to access superclass members\n(attributes, constructors and methods).\nExample:-\nclass Nirmala {\n// overridden method\npublic void display(){\nSystem.out.println(\"Nirmala college\");\n}\n}\nclass deptcs extends Nirmala {\n// overriding method\npublic void display(){\nSystem.out.println(\"Department of computer science\");\n}\npublic void printMessage(){\n// this calls overriding method\ndisplay();\n// this calls overridden method\nsuper.display();\n}\n}\nclass Main {\npublic static void main(String[] args) {\ndeptcs cs = new deptcs();\ncs.printMessage();\n}\n}\nDynamic Method Dispatch or Runtime Polymorphism\nDynamic Method Dispatch in Java is the process by which a call to an overridden\nmethod is resolved at runtime.During the code execution, JVM decides which\nimplementation of the same method should be called.The basis of dynamic method\ndispatch in Java starts with Inheritance where two or more classes exhibit a\nparent-child relationship.\nclass Nirmala\n{\nvoid m1()\n{\nSystem.out.println(\"Nirmala college\");\n}\n}\nclass cs extends Nirmala\n{\n// overriding m1()\nvoid m1()\n{\nSystem.out.println(\"Computer science\");\n}\n}\nclass mm extends Nirmala\n{\n// overriding m1()\nvoid m1()\n{\nSystem.out.println(\"Multimedia\");\n}\n}\n// Driver class\nclass ncas\n{\npublic static void main(String args[])\n{\n// object of type A\nNirmala a = new Nirmala();\n// object of type B\ncs b = new cs();\n// object of type C\nmm c = new mm();\n// obtain a reference of type A\nNirmala ref;\n// ref refers to an A object\nref = a;\n// calling A's version of m1()\nref.m1();\n// now ref refers to a B object\nref = b;\n// calling B's version of m1()\nref.m1();\n// now ref refers to a C object\nref = c;\n// calling C's version of m1()\nref.m1();\n}\n}\nWhen an overridden method is called\nthrough a superclass reference .At\nrun-time, it depends on the type of the\nobject being referred to (not the type of\nthe reference variable) that determines\nwhich version of an overridden method will be executed\nA superclass reference variable can refer to a subclass object. This is also known as\nupcasting.\nIf a superclass contains a method that is overridden by a subclass, then when\ndifferent types of objects are referred to through a superclass reference variable,\ndifferent versions of the method are executed.\nObject class:-\nObject class in Java is the parent class for all the classes.Object Class in Java is the\ntopmost class among all the classes in\nJava.All the classes directly or indirectly\ninherit from the Object class in Java.\nMethods of Object Class\n1. toString() Method\nIt returns a string representation of an\nobject. It is used to convert an Object \"to\nString\".\n2. hashCode() Method\nA hash code is an integer value that gets generated by the hashing algorithm.\nHash code is associated with each object in Java and is a distinct value. It converts\nan object's internal address to an integer through an algorithm. It is not the memory\naddress, it is the integer representation of the memory address.\nSyntax:- public int hashCode()\n3. equals (Object obj) Method\nThis method compares two objects and returns whether they are equal or not. It is\nused to compare the value of the object on which the method is called and the\nobject value which is passed as the parameter.\nSyntax:- public boolean equals(Object obj)\n4. getClass() Method\nIt is used to return the class object of this object. Also, it fetches the actual\nruntime class of the object on which the method is called. This is also a native\nmethod. It can be used to get the metadata of this class. Metadata of a class\nincludes the class name, fields name, methods, constructor, etc.\nSyntax:- Class c = s.getClass();\n5. clone() Method\nThe clone() method is used to create an exact copy of this object. It creates a new\nobject and copies all the data of this object to the new object\nSyntax:- Main obj2 = (Main)obj1.clone();\nMethod Overriding in Java\nThe subclass (child class) has the same method as declared in the parent class, it is\nknown as method overriding in Java.\nIf a subclass provides the specific implementation of the method that has been\ndeclared by one of its parent classes, it is known as method overriding.\nUsage of Java Method Overriding\nMethod overriding is used to provide the specific implementation of a method\nwhich is provided by its superclass.\nMethod overriding is used for runtime polymorphism\nRules for Java Method Overriding\n● The method must have the same name as in the parent class\n● The method must have the same parameter as in the parent class.\n● There must be an IS-A relationship (inheritance).\nclass Nirmala{\n//defining a method\nvoid department(){System.out.println(\"Departments in college\");}\n}\n//Creating a child class\nclass deptcs extends Nirmala{\n//defining the same method as in the parent class\nvoid department(){System.out.println(\"Computer science Department\");}\npublic static void main(String args[]){\ndeptcs obj = new deptcs();//creating object\nobj.department();//calling method\n}\n}\nA static method cannot be overridden.\nJava Abstract Class and Abstract Methods\nJava Abstract Class\nThe abstract class in Java cannot be instantiated (we cannot create objects of\nabstract classes). We use the abstract keyword to declare an abstract class. For\nexample,\n// create an abstract class\nabstract class Nirmala {\n// fields and methods\n}\n// try to create an object Nirmala\n// throws an error\nNirmala obj = new Nirmala();\nAn abstract class can have both the regular methods and abstract methods.\nFor example,\nabstract class Nirmala\n{\n// abstract method\nabstract void deptcs();\n// regular method\nvoid deptmm()\n{\nSystem.out.println(\"This is regular method\");\n}\n}\nJava Abstract Method\nA method that doesn't have its body is known as an abstract method. ‘abstract’\nkeyword is used to create an abstract method. For example,\nabstract void display(); // abstract method\nThe body of display() is replaced by ;.\nIf a class contains an abstract method, then the class should be declared abstract.\nOtherwise, it will generate an error. For example,\nExample:\nThough abstract classes cannot be instantiated, we can create subclasses from it.\nWe can then access members of the abstract class using the object of the subclass.\nFor example,\nabstract class Nirmala {\n// method of abstract class\npublic void display() {\nSystem.out.println(\"NIRMALA COLLEGE\");\n}\n}\nclass deptcs extends Nirmala{\npublic static void main(String[] args) {\n// create an object of deptcs\ndeptcs obj = new deptcs(); Output\n// access method of abstract class NIRMALA COLLEGE\n// using object of deptcs class\nobj.display();\n}\n}\nIn the above example, we have created an abstract class named Nirmala.\nThe class contains a regular method display().\nWe have created the deptcs class that inherits the abstract class.\nobj.display();\nHere, obj is the object of the child class deptcs. We are calling the method of the\nabstract class using the object obj.\nAbstract Method\nIf the abstract class includes any abstract method, then all the child classes\ninherited from the abstract superclass must provide the implementation of the\nabstract method. For example,\nabstract class Nirmala {\nabstract void dispaly();\npublic void cs() {\nSystem.out.println(\"Computer Science.\");\n}\n}\nclass deptmm extends Nirmala {\n// provide implementation of abstract method\npublic void dispaly() {\nSystem.out.println(\"Multimedia\");\n}\n}\nclass ncas {\npublic static void main(String[] args) {\n// create an object of Dog class\ndeptmm m = new deptmm();\nm.display();\nm.cs();\n}\n}\nJava Interface\nAn interface is a fully abstract class. It includes a group of abstract methods\n(methods without a body).We use the interface keyword to create an interface in\nJava.\nFor example,\ninterface Nirmala\n{\npublic void getcsdept();\npublic void getmmdept();\n}\nNirmala is an interface.\nIt includes abstract methods: getcsdept() and getmmdept().\nImplementing an Interface\nLike abstract classes, we cannot create objects of interfaces.\nTo use an interface, other classes must implement it. We use the implements\nkeyword to implement an interface.\nExample 1:\ninterface Polygon {\nvoid getArea(int length, int breadth);\n}\n// implement the Polygon interface\nclass Rectangle implements Polygon\n{\n// implementation of abstract method\npublic void getArea(int length, int breadth)\n{\nSystem.out.println(\"The area of the rectangle is \" + (length * breadth));\n}\n}\nclass Main {\npublic static void main(String[] args) {\nRectangle r1 = new Rectangle();\nr1.getArea(5, 6);\n}\n}\nOutput:- The area of the rectangle is 30\nIn the above example, we have created an interface named Polygon. The interface\ncontains an abstract method getArea().\nHere, the Rectangle class implements Polygon. And, provides the implementation\nof the getArea() method.\nExample 2:\n// create an interface\ninterface Nirmala {\nvoid getName(String name);\n}\n// class implements interface\nclass csdept implements Nirmala {\n// implementation of abstract method\npublic void getName(String name) {\nSystem.out.println(\"Department is \" + name);\n} OUTPUT\n}\nclass ncas {\npublic static void main(String[] args) {\ncsdept cs = new csdept();\ncs.getName(\"COMPUTER SCIENCE\");\n}\n}\nIn the above example, we have created an interface named Nirmala. The interface\nincludes an abstract method getName().\nHere, the csdept class implements the interface and provides the implementation\nfor the method.\nPackages\nA package is a named collection of Java classes that are grouped on the basis of\ntheir functionality. The import keyword is used to load a package into a Java\nprogram.\neg:- import java.io.*;\nJava package is a group of similar types of classes, interfaces, and sub-packages.\nPackages in Java can be categorized in two forms: built-in packages and\nuser-defined packages. There are many built-in packages, such as java, lang, awt,\njavax, swing, net, io, util, sql, etc.\nA package contained in another package is called a sub package.\nBuilt-in packages\nWhen we install Java on a personal computer or laptop, many packages are\nautomatically installed. Each of these packages is unique and capable of handling\nvarious tasks. This eliminates the need to build everything from scratch.\nImporting java.lang\nSyntax:- import java.lang.*;\nimport java.lang.*; to have access to some of the fundamental classes provided by\nJava, such as Math, String, and Integer.\neg:- double area = Math.PI * Math.pow(radius, 2);\njava.lang Provides classes that are fundamental to the design of\nthe Java programming languages such as primitive\nParadise string and math functions\njava.io Provides classes for input and output of data\njava.util Provides classes for printing scanning etc\njava.applet Private classes for implementing applets\njava.awt Provides classes to implement graphical user interface\nProvides classes for networking\njava.net\nUser-defined packages\nUser-defined packages are defined by users . Inside a package, we can have Java\nfiles like classes, interfaces, and a package as well (called a sub-package).\nNesting in java package\nUsing Packages\nThe Calendar class is included in the java.util package. The Calendar class is an\nabstract class that provides methods for converting between a specific instant in\ntime and a set of calendar fields such as YEAR, MONTH, DAY OF MONTH,\nHOUR, and so on.\n/* CalendarClassDemo.java */\npublic class CalendarClassDemo{\npublic static void main(String args[])\n{\njava.util.Calendar cal = java.util.Calendar.getInstance(); //Fully qualified name\nString strDate = \"Today is: + cal.get(java.util.Calendar.DATE) +\n\"/\" + (cal.get(java.util.Calendar.MONTH) + 1) +\n\"/\"+cal.get(java.util.Calendar.YEAR);\nSystem.out.println(strDate);\n} }\nToday is: 2/1/2019\nImporting Packages\nSyntax :- import package1[.package2][.package3].classname;\npackage1 is the name of the top-level package, package2 is the name of the\npackage that is inside the package, and so on (even beyond package3, if needed).\nYou can have any number of packages in a package hierarchy. Finally, specify the\nexplicit classname.\nThe syntax error that occurred in the previous example (see Figure 6.3) can be\nresolved using an import statement. For Example, the statement\nimport java.util.Calendar;\nThere is no need to use the package name to qualify the class. The import\nstatement must appear at the top of the class file, before any declarations. Only\nblank lines, comments, and package statements may precede the list of import\nstatements.\n*************************************************************\n1. What is JVM?\n2. What is the Finalize() method?\n3. Data types in java\n4. Define constructor\n5. Usage of import statement\n6. Built in packages in Java\n7. Difference between constructor and method\n8. Difference between method overloading and overriding\n9. Write a java program to find sum of n numbers in java\n10.Describe history of java\n11.Explain different control statements in java\n12.What is byte code?\n13.Ternary operator in java\n14.Dot operator\n15.Method overloading\n16.Switch statement in java\n17.Explain primitive and non primitive data types in java\n18.Dynamic method dispatch in java\n19.What is polymorphism?\n20.Write a java program to add two complex numbers using operator\noverloading\n21.Explain single inheritance in java with example\n22.Size of char data type\n23.What will be generated after the successful compilation of a source code?\n24.How will give you comments in java?\n25.Purpose of import statement\n26.Explain static method with example\n27.Abstract class and its characteristics with example\n28.Multiple inheritance can be implemented in java\n29.Break and continue\n30.What is inner class?\n31.Purpose of extends keyword\n32.What is variable?\n33.Difference between m++ and ++m\n34.If ……..else statement\n35.For statement\n36.Write a program to add two matrices in using operator overloading\n37.How java is platform independent ?\n38.This keyword\n39.Arrays in java\n40.Looping constructors in java\n41.Literals in java\n42.Keywords\n43.JRE\n44.Interface\n",
  "difficulty": "easy",
  "num_questions": 5,
  "generated_at": 1757425492.2045102
}